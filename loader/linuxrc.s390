#! /bin/bash

# linuxrc.s390: init process of Red Hat's installer initrd for s390(x)
# Copyright (C) 2000-2012 by
#        Bernhard Rosenkraenzer <bero@redhat.com>
#        Oliver Paukstadt <opaukstadt@millenux.com>
#        Karsten Hopp <karsten@redhat.de>
#        Florian La Roche <laroche@redhat.com>
#        Nils Philippsen <nils@redhat.de>
#        Helge Deller <hdeller@redhat.de>
#        David Sainty <dsainty@redhat.com>
#        David Cantrell <dcantrell@redhat.com>
# Copyright (C) IBM Corp. 2008,2009
#        Author: Steffen Maier <maier@de.ibm.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# prerequisites of this script to run inside the installer initrd:
# - udevadm and udevd need to be there
# - have /etc/udev/udev.conf with at least one comment line as content
# - if necessary, have udev rules
# - lsznet.raw and znetcontrolunits from s390utils-base in /lib/s390-tools
# - pack kernel modules and module-init-tools (no longer use busybox for that)
# - "multi on" in /etc/host.conf [RH bugs 486457,486461,483244]

# TODOs:
# - make sure driver modules get loaded automatically
# - udev rule for lcs/ctcm vs. cu3088

# debug: set -x

if [ "${0##*/}" = "reboot" ]; then
    kill -USR2 1
    exit
elif [ "${0##*/}" = "halt" ]; then
    kill -USR1 1
    exit
fi

VERSION=1.2

export TEXTDOMAIN=s390installer
export TEXTDOMAINDIR=/usr/lib/locale

# FIXME: maybe change to "$$" for production use, in case it wouldn't be init
declare -r INITPID="1"

unset testing
[ "$$" != "$INITPID" ] && testing="1"
# uncomment the following test="1" to never execute sensitive commands
#testing="1"

if [ "$RUNKS" = "0" ]; then
    RUNKS=""
fi

# helper function to disable commands while running outside the initrd
function tv() {
    if [ -z "$testing" ]; then
        $*
    else
        return 0
    fi
}

function doshutdown()
{
    echo $"about to exec shutdown"
    /sbin/umount -a -d -n >/dev/null 2>&1
    exec /sbin/shutdown
    exit 0
}

function doreboot()
{
    if [ -e "/sys/firmware/reipl" ]; then
        read REIPL_TYPE < /sys/firmware/reipl/reipl_type
        echo "reipl_type=$REIPL_TYPE"
        pushd /sys/firmware/reipl/$REIPL_TYPE >/dev/null 2>&1
        for i in *; do
            echo "$i=`cat $i`"
        done
        popd >/dev/null 2>&1
    fi

    echo $"about to exec shutdown -r"
    /sbin/umount -a -d -n >/dev/null 2>&1
    exec /sbin/shutdown -r
    exit 0
}

function sysecho () {
    file=$1
    shift
    local i=1
    while [ $i -le 10 ] ; do
        if [ ! -f "$file" ]; then
            sleep 1
            i=$((i+1))
        else
            break
        fi
    done
    [ -f "$file" ] && echo $* > $file
}

function dasd_settle() {
    local dasd_status=/sys/bus/ccw/devices/$1/status
    if [ ! -f $dasd_status ]; then
        return 1
    fi
    local i=1
    while [ $i -le 30 ] ; do
        local status
        read status < $dasd_status
        case $status in
            online|unformatted)
                return 0 ;;
            *)
                sleep 0.1
                i=$((i+1)) ;;
        esac
    done
    return 1
}

function dasd_settle_all() {
    for dasdccw in $(cut -d '(' -f 1 /proc/dasd/devices) ; do
        if ! dasd_settle $dasdccw ; then
            echo $"Could not access DASD $dasdccw in time"
            return 1
        fi
    done
    return 0
}

function startinetd()
{
    echo
    echo $"Starting sshd to allow login over the network."
    if [ -z "$testing" ]; then
        echo $"Welcome to the anaconda install environment $VERSION for $S390ARCH" > /etc/issue.net
        echo $"Welcome to the anaconda install environment $VERSION for $S390ARCH" > /etc/motd
        echo >> /etc/motd
    fi # testing

    /usr/sbin/sshd -f /etc/ssh/sshd_config.anaconda

    # XXX: there may be better files to rely on, also errors may mean something
    iface="$(cat /run/initramfs/net.bootdev 2>/dev/null)"
    if [ ! -z "${iface}" ]; then
        . /run/initramfs/net.${iface}.override 2>/dev/null
    fi

    # copy dracut ifcfg files to keep NetworkManager from downing them all
    DRACUTDIR=/run/initramfs/state
    IFCFGDIR=/etc/sysconfig/network-scripts
    if [ -d ${DRACUTDIR}${IFCFGDIR} ]; then
        mkdir -p ${IFCFGDIR}
        ls -1 ${DRACUTDIR}${IFCFGDIR}/ifcfg-* 2>/dev/null | while read ifcfgfile ; do
            baseifcfg="$(basename ${ifcfgfile})"
            cp ${ifcfgfile} ${IFCFGDIR}
            echo "NM_CONTROLLED=no" >> ${IFCFGDIR}/${baseifcfg}
        done
    fi

    # make sure we have a resolv.conf
    DRACUTRESOLV="$(ls -1 /run/initramfs/state/etc/*.resolv.conf 2>/dev/null)"
    if [ -r ${DRACUTRESOLV} ]; then
        cp ${DRACUTRESOLV} /etc/resolv.conf
    fi

    if [ -z "$RUNKS" ]; then
        echo
        echo $"Connect now to $ip and log in as user 'install' to start the installation."
        echo $"E.g. using: ssh -x install@$ip"
        echo $"For VNC or text mode, disable X11 forwarding (recommended) with 'ssh -x'."
        echo $"For X11, enable X11 forwarding with 'ssh -X'."
        echo
        echo $"You may log in as the root user to start an interactive shell."
        read
        while : ; do
            /bin/sh --login
            [ $? = 0 ] || break
        done
    fi
}

# prints a canonocalized device bus ID for a given devno of any format
function canonicalize_devno()
{
    case ${#1} in
        3) echo "0.0.0${1}" ;;
        4) echo "0.0.${1}" ;;
        *) echo "${1}" ;;
    esac
    return 0
}

# read file from CMS and write it to /tmp
function readcmsfile() # $1=dasdport $2=filename
{
    local dev
    if [ $# -ne 2 ]; then return; fi
    # precondition: udevd created dasda block device node
    if ! dasd_cio_free -d $1 ; then
        echo $"DASD $1 could not be cleared from device blacklist"
        return 1
    fi
    # precondition: dasd_eckd_mod driver incl. dependencies loaded,
    #               dasd_mod must be loaded without setting any DASD online
    dev=$(canonicalize_devno $1)
    if ! sysecho /sys/bus/ccw/devices/$dev/online 1; then
        echo $"DASD $dev could not be set online"
        return 1
    fi
    udevadm settle
    if ! dasd_settle $dev ; then
        echo $"Could not access DASD $dev in time"
        return 1
    fi
    udevadm settle
    if ! cmsfscat -d /dev/dasda -a $2 > /tmp/$2; then
        echo $"Could not read conf file $2 on CMS DASD $1."
    fi
    if ! sysecho /sys/bus/ccw/devices/$dev/online 0; then
        echo $"DASD $dev could not be set offline again"
        return 1
    fi
    udevadm settle
    # consequences of no more module unload: loader can no longer
    # use DASD module option to online DASDs and set other DASD parameters!
}

# adaption of the same function in init.c (udevd gets started later)
function createDevices()
{
    awk '{ printf("mknod /dev/%s %s %s %s\n", $1, $2, $3, $4);
      printf("chmod %s /dev/%s\n", $5, $1);
      printf("chown %s /dev/%s\n", $6, $1);
    }' <<EOF | sh
console c 5 1 600 root:root
null c 1 3 666 root:root
zero c 1 5 666 root:root
mem c 1 1 600 root:root
ptmx c 5 2 666 root:root
tty  c 5 0 666 root:root
tty0 c 4 0 600 root:tty
tty1 c 4 1 600 root:tty
random c 1 8 644 root:root
urandom c 1 9 644 root:root
rtc c 10 135 644 root:root
EOF
    # tty handling is different from init.c since s390 does not have all
    for i in 2 3 4 5 6 7 8 9 ; do
        ln -s console /dev/tty$i
    done
    mkdir /dev/pts
    ln -s /proc/self/fd /dev/fd
}

# approximately the main() function of init.c
function init_main() {
    S390ARCH=$(uname -m)
    if [ "$S390ARCH" = "s390" ]; then
        export S390ARCH="S/390"
    else
        export S390ARCH="zSeries"
    fi

    echo
    echo $"Starting the $S390ARCH initrd to configure networking. Version is $VERSION"

    # set up env vars as we do in init.c
    if [ $(uname -m) = "s390x" ]; then
        LD_LIBRARY_PATH=/lib64:/usr/lib64:/usr/X11R6/lib64:/usr/kerberos/lib64:/lib:/usr/lib:/usr/X11R6/lib:/usr/kerberos/lib
    else
        LD_LIBRARY_PATH=/lib:/usr/lib:/usr/X11R6/lib:/usr/kerberos/lib
    fi
    export LD_LIBRARY_PATH

    PATH="$PATH:/usr/bin:/bin:/sbin:/usr/sbin:/mnt/sysimage/bin:/mnt/sysimage/usr/bin:/mnt/sysimage/usr/sbin:/mnt/sysimage/sbin:/mnt/sysimage/usr/X11R6/bin"
    export PATH
    HOME=/
    export HOME
    PYTHONPATH=/tmp/updates
    export PYTHONPATH

    if [ -z "$testing" ]; then

        mount -t proc none /proc

        mount -t tmpfs none /dev
        createDevices
        # udevd req'd by udevadm settle (/dev/.udev/queue)
        # in readcmsfile, dialog_network_table, semantic_check_subchannels.
        # (important: start udevd at the right time, e.g. after setup of /dev)
        echo $"Starting udev..."
        udevd --daemon
        # debug: udevadm control --log-priority=debug

        udevadm control --env=ANACONDA=1

        mount -t devpts /dev/pts /dev/pts
        mount -t sysfs none /sys

        # remount root fs rw
        mount /dev/root /  -o remount,rw

        # limit output on 3270 console
        # (console_loglevel of 4 is just right to not get driver info,
        #  e.g. from qeth, since that would mix up with the user dialog)
        echo "4 4 1 7" > /proc/sys/kernel/printk

        # make /tmp/ramfs
        mount -t ramfs none /tmp

        # start rsyslogd after mount of /tmp ramfs since it logs to /tmp/syslog
        echo $"Starting rsyslogd..."
        rsyslogd -c 4

        mkdir -p /var/run/dbus
        /bin/dbus-uuidgen --ensure &
        [ $? != 0 ] && echo "error on calling /bin/dbus-uuidgen --ensure"
        /bin/dbus-daemon --system &
        [ $? != 0 ] && echo "error on calling /bin/dbus-daemon --system"

    fi # testing
}

# trigger udev to automatically load device drivers
function udev_setup() {
    if [ -z "$testing" ]; then
       # debug: udevadm monitor &
       udevadm trigger
       udevadm settle
    fi # testing
}

# from here on accesses to sysfs try to follow
# linux/Documentation/sysfs-rules.txt

. /lib/s390-tools/znetcontrolunits

function rollback_config() {
    # set activated DASDs offline again
    local dasd
    while read dasd < /proc/dasd/devices; do
        dasd=${dasd%%(*}
        sysecho /sys/bus/ccw/devices/$dasd/online 0
    done
    udevadm settle
}

### workflow helper functions

# workflow ideas:
# - setting/applying single configuration steps right away save us explicit
#   syntactical & semantic checks PLUS we get direct feedback on error
# - check error level of forked external programs and react on errors

unset reenter
unset redoitem
unset interaction_happened

function reenter() {
    [ -z "$reenter" ] && return 1
    # reenter menu should only be shown if NOT redoing item
    if [ -n "$redoitem" ]; then
        # unset redoitem # wrong => do NOT do this here
        return 1
    fi
    return 0
}

function reenter_menu() {
    local oldvalue=$1
    interaction_happened="yes"
    # unsetting input here is not sufficient, since reenter_menu
    # is not called for predefined parameters
    # which then might get assigned a previous old input of another parameter!
    #unset input
    reenter || return 0
    # don't present reenter menu for empty parameters
    # (currently ignoring parameters that are allowed to be empty!)
    # this could be improved by checking if variable has been set/defined
    #[ -z "$1" ] && return 0
    while : ; do
        if [ -n "$helptext" ]; then
            echo $"0) default is previous \"$oldvalue\", 1) new value, ?) help"
        else
            echo $"0) default is previous \"$oldvalue\", 1) new value"
        fi
        # uncoded alternative: 2) skip parameter
        local answer
        read answer
        [ -z "$answer" ] && return 1
        case $answer in
            0) return 1 ;;
            1)  # Deciding to enter new value gets user out of reenter-mode
                # temporarily for this parameter.
                # To put it differently: redoing does NOT present old values.
                redoitem="yes"
                echo -n $"new value: "
                return 0
                ;;
            "?") input="?"
                return 1
                ;;
        esac
    done
}

function workflow_item_menu() {
    local noredo=$1
    # default is to continue if running kickstart to prevent interaction
    [ -n "$RUNKS" ] && return 0
    interaction_happened="yes"
    while : ; do
        unset redoitem
        if [ "$noredo" = "noredo" ]; then
            echo $"1) continue, 2) restart dialog, 3) halt, 4) shell"
        else
            echo $"0) redo this parameter, 1) continue, 2) restart dialog, 3) halt, 4) shell"
        fi
        local answer
        read answer
        case $answer in
            0) [ "$noredo" = "noredo" ] && continue
                redoitem="yes"
                continue 2
                ;;
            1) return 0 ;; # can be used to break at caller on ignore
            2) reenter="yes"
                rollback_config
                continue 3
                ;;
            3) tv doshutdown
                exit 0
                ;;
            4) echo $"Enter 'exit' at the shell prompt to get back to the installation dialog."
                /bin/bash
                if [ "$noredo" != "noredo" ] && [ -n "$question_prefix" ]; then
                    $question_prefix
                    echo
                fi
                ;; # stay in workflow item menu
        esac
    done
}

# input variables: PARMNAME, question_prefix, question_choices,
#                  "options" ...
# output variables: $question_prefix, $helptext
# modifies: the variable named $PARMNAME, $OPTIND
function ask() {
    [ $# -lt 3 ] && echo "l.$LINENO: too few arguments (<3), please fix calling code." 1>&2
    local PARMNAME=$1
    shift
    question_prefix=$1
    shift
    local question_choices=$1
    shift
    local exception
    local syntax_check
    unset helptext
    local handle
    local finish
    local optname
    OPTIND=1
    while getopts ":e:s:h:c:f:" optname; do
        case $optname in
            e) exception=$OPTARG ;;
            s) syntax_check=$OPTARG ;;
            h) helptext=$OPTARG ;;
            c) handle=$OPTARG ;;
            f) finish=$OPTARG ;;
            "?") ;; # ignore invalid option
            :) echo "l.$LINENO: Missing parameter to option -$OPTARG" 1>&2 ;;
        esac
    done
    while : ; do
        unset input
        local input
        # actually ask question if one of the following is true:
        # - $PARMNAME parameter has not been set yet, e.g. not in parm file
        # - on 2nd and further attempts, i.e. redoing the parameter
        # - on having restarted the whole dialog
        # describing the same from another viewpoint:
        # - if $PARMNAME has been set, try to check syntax and apply
        # - on redo, $PARMNAME has been set and reenter is false,
        #   but still ask question again
        # - on reenter, $PARMNAME might have been set, but still ask question
        if [ -z "${!PARMNAME}" -o -n "$redoitem" -o -n "$reenter" ]; then
            # one empty line to separate parameter questions from each other
            echo
            $question_prefix
            if reenter; then
                echo
            else
                $question_choices
            fi
            # on reenter, give choice between old value and entering new one
            reenter_menu ${!PARMNAME} && read input \
                && [ "$input" != "?" ] && eval ${PARMNAME}=\$input
            # escaping the $ in the RHS of the eval statement makes it safe
        fi
        if [ -n "$helptext" ] && [ "$input" = "?" ]; then
            $helptext
            continue
        fi
        # optional: default or exceptional handling
        [ -n "$exception" ] && $exception
        if [ -n "$syntax_check" -a -z "$handle" ]; then
            # some parameters have only syntax check (and deferred config):
            if $syntax_check; then
                break
            else
                workflow_item_menu && break
            fi
        elif [ -n "$syntax_check" -a -n "$handle" ]; then
            # most common parameters have syntax and configuration:
            # user might still continue on syntax error
            $syntax_check || workflow_item_menu
            # optional: actual configuration
            if $handle; then
                # parmname has been configured successfully
                break
            else
                # user might still continue on configuration failure
                workflow_item_menu && break
            fi
        elif [ -n "$finish" ]; then
            # few parameters need special handling done by their own function:
            $finish
        else
            echo $"Unsupported calling of ask function, please fix calling code"
        fi
    done # PARMNAME
    # disable potential temporary redoing-mode during reenter-mode
    unset redoitem
}

### DASD

function parse_dasd() {
    local handle
    [ "$1" = "-h" ] && handle=yes || unset handle
    local dasditem
    local allgood="yes"
    local cio_wc=$(wc -c /proc/cio_ignore)
    read cio_wc_bytes cio_wc_filename cio_wc_foo <<< "$cio_wc"
    if [ "$handle" = "yes" -a "$cio_wc_bytes" != "0" ]; then
        echo $"Trying to clear specified DASDs from device blacklist..."
        mkdir -p /etc/modprobe.d
        echo "options dasd_mod dasd=$DASD" > /etc/modprobe.d/dasd_mod.conf
        if ! dasd_cio_free; then
            echo $"Not all specified DASDs could be detected within timeout."
            allgood="no"
        fi
    fi
    while read dasditem; do
        unset range features range lo hi rangegood \
            attrs devno lodevno hidevno devbusid sys
        case $dasditem in
            autodetect)
                [ -z "$handle" ] && continue
                cio_wc=$(wc -c /proc/cio_ignore)
                read cio_wc_bytes cio_wc_filename cio_wc_foo <<< "$cio_wc"
                # above we only freed the devices specified in $DASD,
                # so there might still be other DASDs in the blacklist
                if [ "$cio_wc_bytes" != "0" ]; then
                    echo $"Note: There is a device blacklist active! Only activating visible DASDs."
                fi
                local sys
                while read sys; do
                    if ! sysecho $sys/online 1; then
                        echo $"Could not set DASD ${sys##*/} online"
                    fi
                done < <(find /sys/bus/ccw/drivers/dasd-eckd/ -name "*.?.????" 2>/dev/null;\
                    find /sys/bus/ccw/drivers/dasd-fba/ -name "*.?.????" 2>/dev/null)
                ;;
            probeonly|nopav|nofcx)
                if [ -z "$handle" ]; then
                    echo $"DASD option $dasditem not supported by installer"
                fi
                ;;
            "") continue ;; # empty range
            *)  local range features rangegood="yes"
                IFS='('
                read range features <<< "$dasditem"
                unset IFS
                # parse: dev OR dev'-'dev
                local lo=${range%%-*}
                [[ "$lo" =~ (^[[:xdigit:]]+\.[0-3]\.[[:xdigit:]]{4}$)|(^[[:xdigit:]]{3,4}$) ]]
                case $? in
                    0)  # string matched the pattern
                        lo=$(canonicalize_devno $lo) ;;
                    1)  # string did not match the pattern
                        rangegood="no"
                        if [ -z "$handle" ]; then
                            echo $"Incorrect format for lower bound of DASD range $range: $lo"
                            allgood="no"
                        fi
                        ;;
                    2)  echo "l.$LINENO: syntax error in regex of match operator =~, code needs to be fixed" 1>&2 ;;
                    *)  echo "l.$LINENO: unexpected return code of regex match operator =~, code needs to be fixed" 1>&2 ;;
                esac
                if [ "${range//*-*/}" = "" ]; then
                    local hi=${range##*-}
                    [[ "$hi" =~ (^[[:xdigit:]]+\.[0-3]\.[[:xdigit:]]{4}$)|(^[[:xdigit:]]{3,4}$) ]]
                    case $? in
                        0)  # string matched the pattern
                            hi=$(canonicalize_devno $hi)
                            if [ "${lo%.*}" != "${hi%.*}" ]; then
                                echo $"Prefixes of DASD range $range do not match: ${lo%.*} != ${hi%.*}"
                                rangegood="no"
                                allgood="no"
                            fi
                            ;;
                        1)  # string did not match the pattern
                            rangegood="no"
                            if [ -z "$handle" ]; then
                                echo $"Incorrect format for upper bound of DASD range $range: $hi"
                                allgood="no"
                            fi
                            ;;
                        2)  echo "l.$LINENO: syntax error in regex of match operator =~, code needs to be fixed" 1>&2 ;;
                        *)  echo "l.$LINENO: unexpected return code of regex match operator =~, code needs to be fixed" 1>&2 ;;
                    esac
                fi
                if [ "${features//*)/}" != "" ]; then
                    if [ -z "$handle" ]; then
                        echo $"Missing closing parenthesis at features of DASD range $range: ($features"
                        allgood="no"
                    fi
                fi
                local attrs=""
                if [ -n "$features" ]; then
                    features="${features%)}"
                    while read feature; do
                        case $feature in
                            ro) attrs=$attrs" readonly" ;;
                            diag) attrs=$attrs" use_diag" ;;
                            erplog|failfast) attrs=$attrs" "$feature ;;
                            *) if [ -z "$handle" ]; then
                                   echo $"Unknown DASD feature for device range $range: $feature"
                                   allgood="no"
                               fi
                               ;;
                        esac
                    done < <(echo $features | sed 's/:/\n/g')
                fi
                [ "$rangegood" = "yes" ] || continue
                [ "$handle" = "yes" ] || continue
                # now apply $attrs and set DASDs $lo to $hi online
                [ -z "$hi" ] && hi=$lo
                local devno lodevno=$((0x${lo##*.})) hidevno=$((0x${hi##*.}))
                local dasdconf="/etc/dasd.conf"
                for ((devno=$lodevno; $devno <= $hidevno; ++devno)); do
                    local devbusid=$(printf "%s.%04x" ${lo%.*} $devno)
                    local sys="/sys/bus/ccw/devices/"$devbusid
                    echo -n "$devbusid" >> $dasdconf
                    for attr in $attrs; do
                        if [ "$attr" = "use_diag" ]; then
                            # diag discipline cannot be auto-loaded
                            modprobe dasd_diag_mod
                        fi
                        if [ ! -f $sys/$attr ]; then
                            echo $"DASD $devbusid does not provide attribute $attr"
                            continue
                        fi
                        if ! sysecho $sys/$attr 1; then
                            echo $"Could not set attribute $attr for DASD $devbusid"
                        fi
                        echo -n " $attr=1" >> $dasdconf
                    done
                    if [ ! -f $sys/online ]; then
                        echo $"DASD $devbusid not found"
                        continue
                    fi
                    if ! sysecho $sys/online 1; then
                        echo $"Could not set DASD $devbusid online"
                    fi
                    echo >> $dasdconf
                done
                ;;
        esac
    done < <(echo $DASD | sed 's/,/\n/g')
    if [ "$handle" = "yes" ]; then
        udevadm settle
        dasd_settle_all || return 1
        echo $"Activated DASDs:"
        cat /proc/dasd/devices | sed -e 's/ at ([^)]*) is//' -e 's/ at/,/'
    fi
    if [ "$allgood" = "yes" ]; then
        return 0
    else
        return 1
    fi
}

function syntax_check_dasd() {
    parse_dasd
    return $?
}

function handle_dasd() {
    parse_dasd -h
    return $?
}

function question_prefix_dasd() {
    echo -n $"DASD range"
}

function question_choices_dasd() {
    echo $" (e.g. 200-203,205 or ? for help). Default is autoprobing:"
}

function helptext_dasd() {
    echo $" Help text for DASD range:"
    echo $"  Comma separated list of ranges of device bus IDs."
    echo $"  Default is autoprobing (not recommended)."
    echo $"  Examples would be: 200-203 or 200,201,202,203 or 0.0.0200-0.0.0203,0.0.0205"
}

function exception_dasd() {
    [ -z "$DASD" ] && DASD="autodetect"
}

function do_dasd() {
    ask DASD \
        question_prefix_dasd question_choices_dasd \
        -h helptext_dasd -e exception_dasd -s syntax_check_dasd -c handle_dasd
}

### FCP

function syntax_check_fcp() {
    local allgood="yes"
    local i
    for i in ${!FCP_*}; do
        local -a fcp
        local devno wwpn lun
        read -a fcp <<< "${!i}"
        case ${#fcp[@]} in
            3)
                devno=${fcp[0]}
                wwpn=${fcp[1]}
                lun=${fcp[2]}
                ;;
            5)
                devno=${fcp[0]}
                wwpn=${fcp[2]}
                lun=${fcp[4]}
                echo $"Deprecated number of FCP arguments (5 instead of 3): "
                echo $" $i=\"${!i}\""
                echo $" should instead be: "
                echo $" $i=\"$devno $wwpn $lun\""
                ;;
            *)
                echo $"Unsupported number of FCP arguments (${#fcp[@]} instead of 3) in:"
                echo $" $i=\"${!i}\""
                allgood="no"
                continue
                ;;
        esac
        [[ "$devno" =~ (^[[:xdigit:]]+\.[0-3]\.[[:xdigit:]]{4}$)|(^[[:xdigit:]]{3,4}$) ]]
        case $? in
            0)  ;; # string matched the pattern
            1)  # string did not match the pattern
                echo $"Incorrect format for FCP device $devno in:"
                echo $" $i=\"${!i}\""
                allgood="no"
                ;;
            2)
                echo "l.$LINENO: syntax error in regex of match operator =~, code needs to be fixed" 1>&2
                ;;
            *)
                echo "l.$LINENO: unexpected return code of regex match operator =~, code needs to be fixed" 1>&2
                ;;
        esac
        # zfcp.py:class ZFCPDevice would also accept WWPN without leading 0x
        [[ "$wwpn" =~ ^0x[[:xdigit:]]{16}$ ]]
        case $? in
            0)  ;; # string matched the pattern
            1)  # string did not match the pattern
                echo $"Incorrect format for FCP WWPN $wwpn in:"
                echo $" $i=\"${!i}\""
                allgood="no"
                ;;
            2)  echo "l.$LINENO: syntax error in regex of match operator =~, code needs to be fixed" 1>&2 ;;
            *)  echo "l.$LINENO: unexpected return code of regex match operator =~, code needs to be fixed" 1>&2 ;;
        esac
        # zfcp.py:class ZFCPDevice would also accept LUN without leading 0x
        # zfcp.py:class ZFCPDevice would also accept 16 bit LUN and pads with 0
        [[ "$lun" =~ ^0x[[:xdigit:]]{8}0{8}$ ]]
        case $? in
            0)  ;; # string matched the pattern
            1)  # string did not match the pattern
                echo $"Incorrect format for FCP LUN $lun in:"
                echo $" $i=\"${!i}\""
                allgood="no"
                ;;
            2)
                echo "l.$LINENO: syntax error in regex of match operator =~, code needs to be fixed" 1>&2
                ;;
            *)
                echo "l.$LINENO: unexpected return code of regex match operator =~, code needs to be fixed" 1>&2
                ;;
        esac
    done
    if [ "$allgood" = "yes" ]; then
        return 0
    else
        return 1
    fi
}

### MAIN ###

init_main
udev_setup

# Parse configuration
if [ -n "$CMSDASD" -a -n "$CMSCONFFILE" ]; then
    readcmsfile $CMSDASD $CMSCONFFILE
    source /tmp/$CMSCONFFILE #2>/dev/null
fi

if [ -r /sys/firmware/ipl/ipl_type ]; then
    #local ipl_type
    read ipl_type < /sys/firmware/ipl/ipl_type
    if [ "$ipl_type" = "fcp" ]; then
        while : ; do
            echo $"Your IPL device is set to FCP."
            echo $"Would you like to perform a CD-ROM/DVD-ROM installation? (y/n)"
            #local do_cd_install
            read do_cd_install
            case $do_cd_install in
                y|Y|[Yy][Ee][Ss])
                    # precondition: zfcp driver incl. dependencies loaded
                    #local CD_DEVICE WWPN LUN
                    read CD_DEVICE < /sys/firmware/ipl/device
                    read WWPN < /sys/firmware/ipl/wwpn
                    read LUN < /sys/firmware/ipl/lun
                    zfcp_cio_free -d $CD_DEVICE \
                        || echo $"Device $CD_DEVICE could not be cleared from device blacklist"
                    sysecho /sys/bus/ccw/drivers/zfcp/$CD_DEVICE/online 1 \
                        || echo $"Could not set FCP device $CD_DEVICE online"
                    udevadm settle
                    # port (WWPN) appears automatically
                    sysecho /sys/bus/ccw/drivers/zfcp/$CD_DEVICE/$WWPN/unit_add $LUN \
                        || echo $"Could not add LUN $LUN at WWPN $WWPN on FCP device $CD_DEVICE"
                    udevadm settle
                    break
                    ;;
                n|N|[Nn][Oo])
                    break
                    ;;
                *)
                    echo
                    echo $"*** INVALID ANSWER: $do_cd_install"
                    echo
                    unset do_cd_install
                    ;;
            esac
        done
    fi
fi

# Perform a network installation

# Check for missing parameters, prompt for them if necessary
do_dasd
echo $"Initial configuration completed."

# syntax check to give user early feedback on parameters provided in parm file
# (he probably won't notice the logs written by anaconda later on)
syntax_check_fcp
# currently we ignore failed syntax checks since FCP parms are non-interactive
for i in ${!FCP_*}; do
    echo "${!i}" >> /etc/zfcp.conf
done
# cio_ignore handling for FCP should happen when the content of /etc/zfcp.conf
# will actually be processed which is in anaconda's zfcp.py ZFCP::readConfig()

# transfer options into install environment

if [ -z "$testing" ]; then

    # so that the vars get propagated into the sshd shells
    mkdir /.ssh
    cat >> /.ssh/environment <<EOF
LD_LIBRARY_PATH=$LD_LIBRARY_PATH
PATH=$PATH
HOME=$HOME
PYTHONPATH=$PYTHONPATH
EOF

    cat >> /etc/profile <<EOF
LD_LIBRARY_PATH=$LD_LIBRARY_PATH
PATH=$PATH
HOME=$HOME
PYTHONPATH=$PYTHONPATH
export LD_LIBRARY_PATH PATH HOME PYTHONPATH
EOF

    if [ -n "$DISPLAY" ]; then
        echo "export DISPLAY=$DISPLAY" >> /etc/profile
    fi

    # I'm tired of typing this out...
    echo "loader" >> /.bash_history

    echo -n $$ > /var/run/init.pid

    # shutdown (halt) on SIGUSR1
    trap doshutdown SIGUSR1
    # reboot on SIGUSR2
    trap doreboot SIGUSR2

    # create loopback device
    ifconfig lo 127.0.0.1 netmask 255.0.0.0
    route add -host 127.0.0.1 dev lo

    startinetd

    if [ -n "$RUNKS" ]; then
        /sbin/loader
    fi

    doshutdown

fi # testing

# ;;; Local Variables: ***
# ;;; mode: sh ***
# ;;; end: ***
