#!/usr/bin/python2.2

import sys
import os
import os.path
import rpm
import string

# set up rpm dependency whiteouts
import whiteout

# FIXME: we really want this information somewhere, but not in the pkgorder
# file itself.
from rhpl.log import log
from anaconda_log import anaconda_log
anaconda_log.open("/dev/null")
log.handler = anaconda_log


rpmFD = None

import hdrlist
import rhpl.arch

def cmpHeaderByName(h1, h2):
    n1 = string.lower(h1.nevra())
    n2 = string.lower(h2.nevra())

    if n1 < n2:
	return -1
    elif n1 == n2:
	return 0;

    return 1

def addIfNeeded(pkg):
    global pkgOrder, pkgHash
    canon = rhpl.arch.canonArch
    second = rhpl.arch.getSecondaryArch()
    diff = rhpl.arch.archDifference
    if not pkgHash.has_key (pkg.name):
        pkgHash[pkg.name] = [ pkg ]
        pkgOrder.append(pkg.nevra())
    elif second is None:
        # this isn't a biarch arch, so we don't need to worry about
        # multiple glibcs
        return
    else:
        # this is a biarch arch.  we want to just have a primary package
        # for each here
        for p in pkgHash[pkg.name]:
            arch1 = p['arch']
            arch2 = pkg['arch']
            # same arch, don't worry about it
            if arch1 == arch2:
                continue
            # if one of them doesn't work for the canon arch and the other
            # does, then one of them is for the secondary arch and we want
            # to add it.  
            if ( ((diff(canon, arch1) == 0) and (diff(second, arch2) != 0)) or
                 ((diff(canon, arch2) == 0) and (diff(second, arch1) != 0)) ):
                pkgHash[pkg.name].append(pkg)
                pkgOrder.append(pkg.nevra())
        

# set PKGORDER_DEBUG to get rpm debugging
if os.environ.has_key("PKGORDER_DEBUG"):
    rpm.setVerbosity(rpm.RPMLOG_DEBUG)

if len(sys.argv) != 3:
    print "pkgorder <toppath> <arch>"
    sys.exit(1)

arch = sys.argv[2]
distDir = os.path.normpath(sys.argv[1])

if not os.path.isdir(distDir):
    print "error: %s is not a directory" % distDir
    sys.exit(1)

disc1Dir = distDir + "-disc1"
disc1SrcDir = distDir + "-srpms"
disc2Dir = distDir + "-disc2"

# pull in the hdlist
f = distDir + "/RedHat/base/hdlist"
try:
    hdlist = hdrlist.HeaderListFromFile(f)
    hdlist.mergeFullHeaders(distDir + "/RedHat/base/hdlist2")    
except rpm.error:
    print "Failed to read header list", f
    sys.exit(1)
# and read the comps file
grpset = hdrlist.groupSetFromCompsFile("file://%s/RedHat/base/comps.xml"
                                       %(distDir,), hdlist)

# work out the order we'd like to install everything in
pkgOrder = []
pkgHash = {}

# We always want all the kernels-.* in our package list, except for a few
for package in hdlist.keys():
    if (package.startswith("kernel") and
        not package.startswith("kernel-doc") and
        not package.startswith("kernel-source") and
        not package.startswith("kernel-debug")):
        try:
            hdlist[package].select()
        except:
            print package
            print type(package)
        pkgOrder.append(hdlist[package].nevra())
        pkgHash[hdlist[package].name] = [ hdlist[package] ]

# Tier 1 language packages get priority.
tier1langs = ("en:en_US:de:de_DE:es:es_ES:fr:fr_FR:it:it_IT:ja:ja_JP:"
              "ko:ko_KR:zh:zh_CN:zh_TW:pt:pt_BR:en_GB:en_CA")


grpids = grpset.groups.keys()
grpids.sort()
    
# FIXME: this is a hack to get things we want to be first on the CDs earlier
# in a more perfect world, we'd read the installclasses to do this
complist = ["core", "base", "text-internet", "web-server",
            "smb-server", "printing", "dialup", "server-cfg",
            "admin-tools"]
# now let's pull in all of workstation common
if grpset.groups.has_key("workstation-common"):
    comp = grpset.groups["workstation-common"]
    complist.append("workstation-common")
    for name in comp.groupreqs:
        if name not in complist:
            complist.append(name)
# a couple more that make sense to have early
complist.extend(["gnome-desktop", "emacs", "development-tools",
                 "development-libs", "x-software-development",
                 "gnome-software-development", "kde-desktop",
                 "kde-software-development"])
        
latelangs = []
for id in grpids:
    if id in complist:
        continue
    if ((grpset.groups[id].langonly is not None) and
        (tier1langs.find(grpset.groups[id].langonly) == -1)):
        latelangs.append(id)
    else:
        complist.append(id)
complist.extend(latelangs)

# for each comp, staring with base, list the packages
# in alphabetical order.
for id in complist:
    if not grpset.groups.has_key(id):
        continue
    group = grpset.groups[id]
    list = []

    group.select()

    # append what got turned on to our order.
    for p in hdlist.pkgs.values():
        if p.isSelected():
            list.append(p)
    list.sort(cmpHeaderByName)
    for item in list:
        addIfNeeded(item)

# add all of the packages that haven't been added yet.
list = []
for p in hdlist.pkgs.values():
    if not pkgHash.has_key (p.name):
        list.append(p)
list.sort(cmpHeaderByName)
for item in list:
    pkgOrder.append(item.nevra())

# Now set up rpm to run the transaction deporder
testpath = '/tmp/pkgorder-' + str (os.getpid ())
os.system ("mkdir -p " + testpath + "/var/lib/rpm")

ts = rpm.TransactionSet(testpath)
ts.setVSFlags(~(rpm.RPMVSF_NORSA|rpm.RPMVSF_NODSA))
ts.setFlags(rpm.RPMTRANS_FLAG_NOMD5|rpm.RPMTRANS_FLAG_ANACONDA)
for h in pkgOrder:
    #print "in:", h[1000000]
    ts.addInstall(hdlist[h].hdr, hdlist[h].hdr, 'i')
pkgOrder = []

# we have to run ts.check() before ts.order() now to set up the
# alIndex.  
ts.check()
ts.order()

# Get the order back out...
try:
    pkgOrder = ts.getKeys()
except AttributeError:
    print "you don't have the latest RPM!"
    sys.exit(1)

outputted = []
# print the results.
for p in pkgOrder:
    def archSort(hdr1, hdr2):
        h1 = hdlist[hdr1[0]]
        h2 = hdlist[hdr2[0]]
        
        if rhpl.arch.score(h1['arch']) > rhpl.arch.score(h2['arch']):
            return -1
        elif rhpl.arch.score(h1['arch']) < rhpl.arch.score(h2['arch']):
            return 1
        return 0
    
    if p['name'] in outputted:
        continue
    pkgs = hdlist.pkgnames[p['name']]
    pkgs.sort(archSort)
    for pnevra in pkgs:
        pkg = hdlist.pkgs[pnevra[0]]
        print "%s-%s-%s.%s" % (pkg['name'], pkg['version'],
                               pkg['release'], pkg['arch'])

